---
title: iOS丨开发中的小知识点
date: 2020-06-14 19:28:12
categories:
    - iOS
tags: 
    - iOS
mathjax: true
---

一些零碎的知识点，并没有深入，只是记录在这里方便查漏补缺。后续会针对一些部分专门的研究写文章。

### 函数签名
用函数签名对变量进行赋值，可以用于在更上层的模块有对应的方法，比如说一个点击的方法，当前这个模块的点击行为实际上是给到了更上层的方法中去调用，这个时候就可以在下层的模块中去定义一个函数签名。
<!--more-->
### xcode自动补全
注意xcode自动补全的时候，有时候函数是重载的，如果直接自动补全的话实际上是选择了一种函数，可能和对应要使用的方法不同，这样就会报错（数据结构不同、返回值不同等）。要注意。

### 关于Delegate的理解
Delegation是常用的一种设计模式，理解为委托人——协议——代理人。delegate就是代理，首先在协议中声明所有的方法，这个部分是声明为protocol的。接下来对每种方法进行定义，全部放在delegate底下。之后全部的方法的调用全部用delegate来处理。这样实际上把具体的操作和业务的逻辑分开。最后要进行更改也会简单一点。

注意代理一定使用的是弱引用，参考C++的智能指针，默认的强引用会有循环引用的问题。

### 组件化
尽量将组件都公有化使用，每个单个的使用场景都通过一个serviceCenter来进行处理，可以通过switch等方式去处理不同的场景。这样在后期更改需求的时候会便于处理。

### Notification
通知是全局的，因此在需要接受通知的地方`addbserver`，里面的参数包含
- 监听者：一般是自己也就是self
- selector：监听到之后所调用的方法，这个方法是要加@objc
- name：监听事件的名称，这个名称可以是自定义的，apple也提供了几种名称，比如view被调到前台等

在一个类里面如果要监听多个通知，可以抽象出一个单独的方法去receiveNotification，在里面根据name的不同进行其他的操作

在发出通知的地方使用post，包含的参数是一个Notifaction结构体，一般传递的参数：
- name：监听事件的名称
- object：当前发出通知的对象，其实一般也是self
- 还可以传递其他的参数，事实上Notification的结构内部有很多参数可以使用，可以在UserInfo这个参数中进行传递`public var userInfo: [AnyHashable : Any]?`

### 关于动画的问题
一种常用的方法是`UIView.animate()`,这种方法实际上是使用关键帧的技术。在`animation`里面去定义最后要完成的动作，在option里面定义过渡的动画曲线，定义了动画形成的过渡期动画。通过设置别的参数如`duration`,`usingSpringWithDamping`等参数来设置具体的动画类型。

至于一些常见的动画，位移的动画实际上就是在animation时重新去设置view的frame位置，呈现出来就是位移的动画。渐变的动画是alpha的变化。图形放大和缩小的动画是transform的改变，矩阵的计算最终影响到图形的变化。颜色的改变和渐变是一样的。Tableview的展开实际上就是在section里面加单元。箭头之类的动画（需要旋转的动画）需要使用rotateView来进行控制，

主要需要手动写的动画就是位移和渐变，缩放的动画都十分少见。稍微麻烦一点的动画都是使用lottie直接去调设计给的json文件。有些情况下需要两种方式一起使用，在`artist follow`的动画需要位移的同时播放动画。注意使用到lottie的时候，要去设置currentProgress，因为实际上执行的是一个ae文件，一个整的动画是有进度条的，因此要设置一下动画进行到哪里了。

lottie在swfit中使用对性能是有损耗的（事实上在oc或者安卓都存在）。原因可能在于一是需要IO读取json，二是解析json时产生的消耗。因此对于经常会触发的动画，应倾向于使用UIView或者CoreAnimation实现；对于复杂的或者是不是很经常触发的动画可以直接lottie。

UIView和CALayer是平级关系。UIView更偏向于VC，处理用户的交互；CALayer更倾向于展示图像。一个CALayer里的内容content就是一个纹理，直接可以输入片源着色器。所有的渲染是CoreAnimation做好了处理之后，draw call进行发送到GPU进行真正的渲染过程。

### 布局
#### frame
常用的布局方式。布局的结果是绝对位置，因此在不同的机器上可能展示的不同。因此可以看到针对不同尺寸大小的机器有着判断。
#### snapkit
snapkit实现的也是自动布局，但相比起autolayout代码要简洁很多。其思想也是相对位置，定义当前视图和父视图的相对位置来实现自动布局，也就是每一次布局要计算一次新的参数。
对于大的页面中的布局应当使用snapkit来写，snapkit的方式在项目中比较常见。一些小的内部的布局可以直接frame写。
#### autolayout
写起来比较繁琐，而且存在性能问题，其中的textlayout对性能的影响较大，而且autolayout会把textlayout放在主线程。


### 页面跳转
#### UINavigationController
最常见的一种方式。使用栈的方式，push的时候将目标的vc push到栈顶。只有栈顶的vc才会被展示。默认的动画效果是从右到左缓慢推出,默认的无动画效果是从右到左一闪而过。
#### Segue
只有在storyboard里面才会使用。
#### model跳转
使用model进行跳转的特点在于视图会从下到上出现覆盖掉当前的视图。

### IB or 手写
写页面两种方法：storyboard+nib或者代码。使用interface builder的好处是操作会简单的一点，当然项目里面是没有这样做的，都是用代码的方式直接去写。直接看iphone上安装好的文件的话，可以看到nib文件，这些文件实际上是这个软件的界面文件。本质上是xml格式。如果多人协作，同时使用Interface Builder去修改一个view，nib文件一定会冲突，从git的冲突信息来看，你很难（或者无法）去修正它。xcode从5.0之后开始支持简单的冲突合并，不过本质上还是会产生诸多的冲突问题。

### GCD
swift在做多线程中主要使用的是GCD，通过集中管理线程池的方式处理并发的问题。GCD中使用的队列是FIFO，队列一共有两种类型：串行和并行。系统提供了五个全局队列：main。和四种优先级不同的全局队列，由上到下是`userInteractive`、`userInitiated`、`utility`、`background` .一般情况下queue都需要尽快处理，所以默认的qos默认是`userInteractive`。

线程切换的时候，为了不阻塞主线程，可以将耗时的任务放到其他线程。等到任务结束的时候再切换到主线程操作，比如说更新一些UI。

DispatchGroup用于想要等到队列里的所有任务都执行完毕的时候在执行某些操作。在开始的时候在对应的group enter，在执行成功之后在对应的地方leave。group会在执行完所有的操作之后继续其他的操作。

DispatchWorkItem用于安排队列要执行的任务，使用workitem的好处在于可以取消掉一个还未执行的新的请求，比如说在用户search的时候，用户每输入一个字符就会联想搜索一次，为了避免过多的查询请求，可以使用workitem来取消掉。

DispatchSemaphore用于线程同步使用的信号量。



