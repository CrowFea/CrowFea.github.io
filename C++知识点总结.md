---
title: C++知识点总结
date: 2020-01-29 22:26:45
categories:
    - C++
tags: 
    - C++
cover: http://domain.com/awesome.jpg
---

### 面向对象
#### 封装
将客观事物封装成抽象的类，类可以将自己的数据和方法只让可信的类或者对象操作，对不可信的信息进行隐藏。默认为private。
- `public` ：可以被任意实体访问
- `protected` ：可以被子类及本类的成员函数访问
- `private` ：可以被本类的成员函数和友元类、友元函数访问

这几个关键字可以出现无数次。

*protected是传家宝，只可以在家族中访问；private是日记本，可以分享给自己和朋友，但不会告诉家人*

#### 继承
基类/父类 —— 派生类/子类

#### 多态
多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。多态是以封装和继承为基础的。

C++的多态有四种形式。编译期的多态为静态多态、运行期的多态为动态多态。
- 重载（编译器）：函数重载、运算符重载
- 参数多态（编译期）：类模板、函数模板
- 子类型多态（运行期）：虚函数
- 强制多态（编译期/运行期）：基本类型转换、自定义类型转换

多态相关有几个问题：
- 重载的规则
    - 函数名称必须相同
    - 参数列表必须不同（个数、类型、排列顺序）
    - 函数的返回类型可以相同也可以不同
    - 仅仅返回类型不同不构成重载

- C语言为什么不支持多态

    编译器在编译.c文件的时候，只会给函数进行简单的命名（在函数名前面加_)，因此无法区分重载函数。

    C++在处理重载的时候，其编译器在符号表中的名称不同。如 `?Add@@YAHHH@Z` ：`?`表示名称开始，后面接函数名，`@@YA`表示参数表开始，后面三个表示返回值类型、参数类型，`@Z`表示名称结束。

- 虚函数的机制
    ![img](https://s2.ax1x.com/2020/01/29/1MzAdU.png)

- 虚函数的规则
    - 非类成员函数不能是虚函数
    - 静态函数不能是虚函数
    - 构造函数不能是虚函数
    - 内联函数不能是表现多态性时的虚函数

- 虚函数和纯虚函数
    纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。
    ```c++
    virtual int A() = 0;
    ```

    - 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 
    - 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。
    - 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 
    - 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
    - 虚基类是虚继承中的基类。

#### 几种特殊的类
- 抽象类：含有纯虚函数的类
- 接口类：仅含有纯虚函数的抽象类
- 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
    - 所有成员都是 public
    - 没有定义任何构造函数
    - 没有类内初始化
    - 没有基类，也没有 virtual 函数

### 内存分配及管理
- malloc：分配指定字节数的内存，初始值不确定
- calloc：为指定长度的对象分配能容纳其个数的内存。每一位初始化为0
- realloc：更改以前分配的内存长度，初始值不确定
- alloca：在栈中发申请内存，出栈时自动释放内存，不具有移植性。

#### new和delete
相比而言，new和delete实际上都干了两件事：首先调用malloc/free分别申请/释放了内存；接下来调用构造/析构函数。

定位`new（placement new）`允许我们向new传递额外的地址参数，从而在预先指定的内存区域创建对象。
```c++
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] { braced initializer list }
```
`place_address` 是个指针；`initializers` 提供一个（可能为空的）以逗号分隔的初始值列表。

#### delete this
合法，但：
- 必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的
- 必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数
- 必须保证成员函数的 delete this 后面没有调用 this 了
- 必须保证 delete this 后没有人使用了

#### 如何定义一个只能在堆上（栈上）生成对象的类?
- 只能在堆上：将析构函数设置为私有

    原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。

- 只能在栈上：将 new 和 delete 重载为私有

    原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

#### 分配位置
malloc和new分配都在堆上；函数内的局部变量、形参都是在栈中，自动释放的。

### sizeof()
返回对象的字节数
- char：1
- bool：1
- short：2
- int：4
- long：4
- float：4
- double：8
- 指针：32位为4，64位为8
- 结构体：空结构体为1，其余注意对齐
- 类：空类为1，多个虚函数按一个指针对待，继承类要加上父类的大小
- union：每个成员的最大值
- 字符串：加上'/0'
- 数组：基本数据类型×数量；为形参时，按指针处理
- 函数：
    - 结果为函数返回值类型的大小，函数不会被调用
    - 不可以对返回值类型为空的函数求值
    - 不可以对函数名求值（写括号）
    - 对有参数的函数，需要写上实参表
- pragma pack(n):按n对齐处理


### 算符优先级
```
1.     ()    []     .     ->
2.     !     ~     ++     --     +     -     *     &    (type)    sizeof
3.     *     /     %
4.     +     -
5.     >>    <<
6.     >     >=     <     <= 
7.     ==    !=
8.     &
9.     ^
10.    |
11.    &&
12.    ||
13.    ? :
14.    =     *=     /=     %=     +=     -=     >>=     <<=     &=     ^=     |= 
15.    ，
```

### 大端小端
大端存储：低地址位存储高位；小端存储：高地址位存储高位