---
title: 杂七杂八的算法小技巧
date: 2019-12-2 20:32:12
categories:
    - 算法
tags: 
mathjax: true
---

记录一些很小的算法的小技巧，长期更新。

#### int *last = NULL;
有些时候在排序，或者是树相关的问题时，我们希望有一个变量表示着刚刚走过的变量的值。在申请这个变量的时候，往往要对第一次特殊处理，要么单独处理一次，在第一次后引入新的变量；要么就是一开始将这个对比值设的极大或者极小。这样都不是很好，可以直接将变量设为指针，不赋初值。每一次判断是否为NULL，如果是，就说明是第一次，直接通过；如果不是，进行该进行的判断。注意在每次把上一个的值赋给last的时候要写取址符号
```c++
last = &val;
```

### 主对角线为横纵坐标之差，次对角线为横纵坐标之和
在二维数组内查找的时候，沿对角线查找可能会写的很复杂，记住上面的公式，可以减少代码量和开销。

### 实现sqrt函数
有的会说用牛顿迭代法，但实际上在代码中就是二分。比如说求x的平方根，设下限为0，上限为x，不断二分判断是否$x/i<i$，注意不能直接$i*i$，这样会溢出。
```c++
int mySqrt(int x) {
        if(x==1)    return 1;
        int l=0,h=x;
        while(h>l+1){
            int mid = (l+h)/2;
            if(mid>x/mid)   h=mid;
            else    l=mid;
        }
        return l;
    }
```

### 快速幂
既然写了平方根就把快速幂也写一下吧，基本的思路都相同。都要注意**溢出问题**。
```c++
double myPow(double x, int n) {
        if (n == 0)
            return 1.0;
        double tmp = myPow(x, n / 2);
        if (n % 2)
            return n < 0 ? 1 / x*tmp*tmp : x*tmp*tmp;
        else
            return tmp*tmp;
    }
```

### 反转链表相关
#### 反转全部链表
反转链表是个好玩的问题。据传HomeBrew的作者去Google面试，因为写不出反转链表被拒了。这个问题有个一般的解法，就是用两个指针来回倒，思路清晰一点就行。还有一个很简便但是不太好理解的方法:
```c++
ListNode* reverseList(ListNode* head) {
        ListNode *p;
        for(p=NULL; head; swap(head,p))
            swap(p,head->next);
        return p;
    }
```

这个方法实际上是把链表最后的NULL看作一个节点，每次都更换头和尾
更一般的做法是
```c++
ListNode* reverseList(ListNode* head) {
    struct ListNode* prev = NULL;
    struct ListNode* curr = head;
    struct ListNode* next = NULL;
        
    while (curr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
        
    return prev;
 }
```
#### 反转部分链表
接下来一个升级版是，反转从位置m到n的链表，上述的简便方法也可以使用
```c++
ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode H(-1), *left, *right;
        for(n=n-m+1, H.next=head, left=&H; --m; left=left->next);
        for(right=NULL, head=left->next; n--; swap(head,right))
            swap(right,head->next);
        left->next->next=head;
        left->next=right;
        return H.next;
    }
```

更一般的方法是
```java
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode pre = dummy;
        for(int i = 1; i < m; i++){
            pre = pre.next;
        }
        head = pre.next;
        for(int i = m; i < n; i++){
            ListNode nex = head.next;
            head.next = nex.next;
            nex.next = pre.next;
            pre.next = nex;
        }
        return dummy.next;
    }
}

```

### 旋转排序数组相关
旋转排序数组的设定是已经是排好序的数组，绕着数组中的某一点进行旋转。在旋转数组中有若干的问题，基本是寻找旋转点、寻找某个特定值等。基本都可以通过二分法解决。分出来的一半有序、另一半无序；接下来将无序的部分继续二分。

这里有一个问题，就是如果旋转数组中有重复的数，可以通过一个简单的操作解决，就是发生mid==high的时候，将high--，跳过这个重复值。

### 计算器
前几天做csp ccf的题，很不习惯没有实时反馈ac的oj……但确实也显现了一些问题，在写一个简单的加减乘除计算器的时候犯了错。用栈写的，遇到乘除计算、最后统一算栈内的加减。但要注意的是，栈是先算后面的算式，所以如果前面有减号后面要变号。因此建议每一次碰见减号直接变成负数和加号。

### upperbound
upperbound(begin,end,num)用于返回从begin到end之间，第一个大于num的数的位置。

lowerbound(begin,end,num)用于返回从begin到end之间，第一个小于等于num的数的位置。

### 跳台阶
跳台阶类型的题目都可以这样想：dp[当前的台阶]=sum dp[能从上一个跳到当前位置的台阶];

比如经典的跳一个或者跳两个的就是
```c++
dp[i]=dp[i-1]+dp[i-2];
```
如果每次都能跳2的幂次，就要从当前台阶往前数，每数到一个2的幂次就加上
```c++
for(int i=2;i<n;++i){
    for(int j=1;j<=i;j*=2){
        dp[i]+=dp[i-j];
    }
}
```


### 取模
如果感觉数比较大，要取模的话，试一试1e9+7，或者1e9+3。注意不要写科学计数法，写1000000007或者1000000003。