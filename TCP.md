---
title: TCP
date: 2020-2-3 19:21:12
categories:
    - 网络
tags: 
    - TCP
mathjax: true
---

### TCP背景
UDP，在传送数据前不需要先建立连接，远地的主机在收到UDP报文后也不需要给出任何确认。虽然UDP不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是UDP。对应的应用层的协议主要有 DNS,TFTP,DHCP,SNMP,NFS 等。

TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP,TELNET,HTTP,FTP 等。

### Socket
TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。

### TCP报文格式

![img](TCP/1797490-442b3c96204460ae.png)

- 原端口号
- 目标端口号
- 序列号
- ACK“字段长度32位。是指下一次应该收到的数据的序列号。 实际上，它是指已收到**确认应答号**减一为止的数据。发送端收到这个**确认应答**以后可以认为在这个序号以前的数据都已经被正常接收。因此当前报文段最后一个字节的编号+1即为**确认应答号**。
- 偏移量：指该字段表示**TCP**所传输的数据部分应该从**TCP**包的哪个位开始计算，当然也可以把它看作**TCP首部**的长度。该字段长4位，单位为4字节。（比如该值为4就表示TCP所传输的数据从16个字节的地方开始）；如果不包括选项字段的话，此**数据偏移**字段可以设置为5。反之，如果该字段的值为5，那说明从**TCP**包的最一开始到20字节为止都是**TCP**首部，余下的部分为**TCP**数据。
- 保留量：保留一段，以备扩展
- 控制命令：8位控制命令，从左至右依次为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。
	- CWR：
	- ECE：为1时通知对方拥塞窗口减小
	- URG：为1时表示包中有需要紧急处理的数据，与后面的紧急指针一起使用
	- ACK：为1时表示接受确认
	- PSH：为1时表示收到的数据必须立即传给上层协议，为0时缓存
	- RST：为1时表示异常，必须强制断开连接
	- SYN：建立连接时使用
	- FIN：表示TCP连接结束
- 窗口大小：该字段长为16位。用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小TCP不允许发送超过此处所示大小的数据。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。
- 校验和
- 紧急指针：该字段的数值表示本报文段中紧急数据的指针。从数据部分的首位到紧急指针所在的位置为止是紧急数据。因此，紧急指针是指出了紧急数据的末尾在报文段中的位置； 
- 选项：长度可变
- 填充
- 数据

### 三次握手
三次握手用于建立连接
ACK为控制位，ack表示确认应答号

**第一次握手：**
客户端向服务端发送**连接请求**报文段。该报文段的头部中**SYN=1**，**ACK=0**，同时选择一个初始序号**seq=x**。请求发送后，客户端便进入**SYN-SENT**状态。

**第二次握手：**
服务端收到连接请求报文段后，如果同意连接，会发送一个应答：**SYN=1，ACK=1，seq=y，ack=x+1**。发送完应答后服务端进入**SYN-RCVD**状态。

**第三次握手：**
客户端收到服务端连接同意的应答后，还会向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：**ACK=1，seq=x+1，ack=y+1**。该报文发送完毕后，客户端和服务器端都进入**ESTABLISHED**状态，完成**TCP三次握手**。

#### 为什么不是两次握手
在一次TCP连接中，客户端A向服务端B发送连接**请求SYN报文段**，假如这个报文段没有及时被服务端B接收，而是**滞留**在网络的某处，于是客户端A超时重传，再次发送请求连接并且顺利与服务端B建立了连接，交换数据后断开连接。滞留在网络中的某处的陈旧报文就变成了失效的连接请求报文。
但如果这个失效的**请求SYN报文段**，现在又突然传送到了服务端B处，设想这时是使用两次握手而不是三次握手，服务端B就以为客户端A现在建立请求连接，于是服务端B发出确认，新的连接就建立了，服务端B分配资源，等待客户端A传送数据，但客户端A并没有想要建立**TCP连接**，不会理会服务端B发送的应答，也不会向服务端B传送数据，于是服务端B就白白等待，空耗资源。

使用**三次握手**可以避免这个情况。服务端B收到客户端A的失效的**陈旧SYN报文段**，向客户端A发送SYN报文段，选择自己的序号**seq=y**，确认收到客户端A的SYN报文段，确认号**ack=x+1**。第三次握手客户端A收到B的SYN报文段后，从确认号就可得知不应理睬这个**SYN报文段**（因为A现在并没有发送**seq=x**的报文段）。这时，客户端A会发送复位报文段，这个复位报文段中，**RST=1，ACK=1，确认号ack=y+1**。服务端B收到A的复位报文，就知道不建立TCP连接，不会分配资源等待A发送数据。

### 四次握手
四次握手用于断开连接

**第一次挥手**
客户端数据发送完成，则它向服务端发送连接释放请求。该请求只有报文头，头中携带的主要参数为：**FIN=1，seq=u**。此时，客户端将进入**FIN-WAIT-1**状态。TCP规定，**FIN报文段**即使不携带数据，也要消耗一个序号。

**第二次挥手**
服务器收到客户端连接释放报文，通知相应的高层应用进程，告诉它客户端向服务器这个方向的连接已经释放了。此时服务端进入了**CLOSE-WAIT（关闭等待）**状态，并向客户端发出连接释放的应答，其报文头包含：**ACK=1，ack=u+1，seq=v。**
客户端收到该应答后，进入**FIN-WAIT-2**状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
第二次挥手完成后，**客户端到服务端方向的连接已经释放**，服务端不会再接收客户端的数据，客户端也没有数据要发送了。但服务端到客户端方向的连接仍然存在，服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个**CLOSE-WAIT**状态持续的时间。

**第三次挥手**
服务端将最后的数据发送完毕后，就向客户端发送连接释放报文，其报文头包含：**FIN=1，ack=u+1**，由于在**CLOS-WAIT状态**，服务端很可能又发送了一些数据，假定此时的序列号为**seq=w**，此时，服务器就进入了**LAST-ACK（最后确认）状态**，等待客户端的确认。

**第四次挥手**
客户端收到服务器的连接释放报文后，向服务端发出确认应答，报文头：**ACK=1，ack=w+1，seq=u+1**，此时，客户端就进入了**TIME-WAIT（时间等待）状态**。该状态会持续**2MSL（最长报文段寿命）时间**，这个期间TCP连接还未释放，若该时间段内没有服务端的重发请求的话，客户端就进入**CLOSED状态**，服务端只要收到了客户端发出的确认，立即进入**CLOSED状态**。就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

### 安全机制
**TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。**


### TCP怎么保证可靠性

TCP保证可靠性：

1) 序列号、确认应答、超时重传
数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送方迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。
2) 窗口控制与高速重发控制/快速重传（重复确认应答）

	TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。
	使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……
3) 拥塞控制

	如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。
	慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。

	拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。

	将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。

	快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。

	然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。

	这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。

### 如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。




