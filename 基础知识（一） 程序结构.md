---
title: Go学习笔记丨基础知识（一） 程序结构
date: 2020-4-1 13:14:12
categories:
    - Go
tags: 
    - Go
mathjax: true
---

### 命名
Go同样是大小写敏感的语言，建议的命名规则为驼峰。
内含关键字如下：
```
break	case	chan	const	continue
default	func	defer	go	else	goto
fallthrough   if	for	import	interface
map	package	range	return	select	
struct	switch	type	var
```
内建常量: 
```
true false iota nil 
```
内建类型:
```
int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr 
float32 float64 complex128 complex64
bool byte rune string error
```
uint/int的默认大小为8字节，其余的带数字的类型字节大小为后面数字除以8
bool大小是1，string大小为16

内建函数: 
```
make len cap new append copy close 
delete complex real imag panic recover
```

Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样。通常来说，如果一个名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。

### 声明
Go语言有四种声明方法
```
var	const	func	type
变量	常量		方法		类型
```
包一级的声明无所谓顺序。

### 变量
#### 简单方式
简单的变量有两种声明方式：一种是显示的声明，该方式会显示的定义变量的类型；一种是隐式的声明，也称简短声明
```
var x int = 4
x := 4
```
Go支持不同类型的多重声明
```
x,y,z := 32,4.02,true
```
同样对于函数的返回值，与C++不同的是，可能一直函数有多个返回值，那么我们需要给出对应数量的变量用来获取返回值
```
f, err := os.Open(name) 
```

- 关于简短声明
第一点是，简短声明时必须至少有一个是新的变量。换言之，当简短声明时有已经存在的变量，将自动的变为对该变量的赋值
```
x := 1
x,y := 3,2	//x=3,y=2
```
第二点是，关于简短声明下自动判断变量的类型，一个浮点数默认为int64，整数默认为int。

#### 指针
指针需要注意的是一种特殊情况，在调用函数时返回的指针，在该函数结束后，该指针指向的内存并不会释放。
```
var p = f() 
func f() *int {
    v := 1
return &v } 
```
这里的p指向的区域是有效的，该内存中的值也不会销毁。也就是说，这个v变量将从他的作用域中逃逸。

#### new
另外一种声明变量的方法是new。
```
p := new(int)
```
注意两点：
- new是预定义的函数而非关键字，因此理论上可以拿它当变量名（最好不要）
- Go语言对内存的分配与new无关，并非一定会new在堆上，也并非var在栈上。决定在根本在于该变量是否是局部的，如果是，就在栈上。比如上面提到的逃逸的`v`，就会分配在堆上。

### 赋值
赋值右侧为表达式即可。赋值支持特殊的二元运算符如`+= -= *=`等。

要注意的是`i++`是语句而不是表达式，因此以下都是不合法的
```
//注意，以下均不合法
++i
x = i++
```

同时Go支持元组赋值，这样一定程度带来了便利，比如我们可以轻松的交换元素。
```
x,y = y,x
```
因此我们可以较为轻松的写一些简单的算法，比如
```
func GCD(x,y int) int{
	for y!=0 {
		x,y = y,x%y
	}
	return x
}

func Fibbonacci(n int) int {
	x,y := 0,1
	for i:=0;i<n;i++ {
		x,y = y,x+y
	}
	return x
}
```
在处理函数返回值时，和变量声明一样，我们可以用下划线空白标识符 `_`来丢弃不需要的值。
```
_, err = io.Copy(dst, src) // 丢弃字节数
_, ok = x.(T) // 只检测类型，忽略具体值 
```

### 类型
使用`type 类型名字 基础类型`就可以对类型名称自定义。值得注意的是，即使两个相同底层数据结构的类型，也不具有可赋值性，除非进行强制转换。
```
type a int
type b int

func main(){
	var x a;
	var y b;
	x=y	//error type mismatch
	x=a(y) //good
}
```
