---
title: 渲染管线
date: 2019-11-27 15:26:12
categories:
    - 图形学
tags: 
    - 图形学
mathjax: true
---

渲染管线是一个非常重要的概念，同时涉及的东西也非常多。在不同的书籍上阅读过相关的篇章，没有系统的总结过，这篇文章大致总结一下，一些经常在文章里出现的地方就不赘述，着重记录一些我不太理解的东西。

参考书目
《Fundamentals of computer graphics Third Edition》
《Real-time rendering 4th Edition》
《Unity Shader入门精要》

### 在渲染管线之前
渲染管线听起来似乎很高大上的样子（其实就是），但是说的通俗一点就是流水线渲染。管线（Pipeline）就是我们熟知的流水线技术，这个在设计CPU的时候已经饱经荼毒。渲染管线就是使用流水线技术对图形进行渲染，使得硬盘中的数字图形信息显示在屏幕上。

很多书籍和博客在这一部分会直接开始看流水线流程，尽管如此，本文还是想先写一下渲染管线的目标是什么。搞明白这个才知道为什么要设计管线。还记得[Ray Tracing简介](https://crowfeablog.com/2019/07/26/Ray%20Tracing%E7%AE%80%E4%BB%8B/)这个文章么，其中我们提到了两种渲染的方法：
*   object-order rendering

    遍历每个object，计算object对于每个像素的贡献。
*   image-order rendering

    遍历每个像素，计算当前像素有哪些object的贡献。
一般来说会更一般的使用第一种方法，object-order的效率要更高。考察每一个几何图元中的像素的过程称为**Rasterization**。而将每一个object逐个渲染到屏幕上，需要一个序列的操作，起始为objects（各种模型数据），终止为对屏幕像素的更新，这个过程称为图形管线。

应当注意的是图形管线并不定论，他只提供一个理论上的通用方法。对于不同的场景，会缠上许多不同的管线。比如硬件管线需要运行的足够快才能使得图形看起来“真”，一些电影的管线需要渲染大规模的复杂场景，但是需要运行很久。

### 图形渲染管线

无论怎样，渲染管线都应该包含一些相同的结构，如下图所示。

![GPU](https://s2.ax1x.com/2019/11/27/QCpVHJ.png)
*图来源于 Real-time rendering 4th Edition*

在入门精要中，后两个阶段合并为一个阶段叫光栅化阶段；在Fundmentals of Computer Graphics里面，只是着重强调了顶点着色器、栅格化、片段着色器三个部分。实际上，在之前编写shader的过程中，我们打交道最多的两个部分，就是顶点和片段着色器。可编程管线里面基本上就是这个，因此其实可以做出这样的理解：对于这个图形渲染的过程，有一条大的流水线，包括了从CPU到GPU的过程；在这之中每一部分都是小的管线，我们额外注意的是在GPU中进行的部分，也就是拿到了顶点数据后，开始vertex shading到Merging的部分，即上图中的几何阶段、栅格化阶段和片元着色阶段。

### Application阶段
对于此阶段不做过多的描述，Application往往发生在CPU中，这一阶段是对要进行渲染的数据进行整理，包括模型数据、纹理、shader等打包好之后扔给GPU（GPU：我就是个工具人）。

值得一提的是，CPU在要发出渲染要求的时候，会发送一个Draw Call指令给GPU，其中包含了要渲染的各种数据。这其中牵扯了一些性能的问题。首先我们来看GPU的流水线设计，不仅仅是在操作序列上的流水线，而是在每一层操作间有大量的并发操作。比如下面这样

![GPU](https://s2.ax1x.com/2019/11/27/Q9HCUU.jpg)
*图来源于 The Book of Shader*

这是因为GPU每次计算需要计算大量的像素，我们现在的PC一般的分辨率也可以达到1920*1080，，如果帧数按60 FPS计算，这意味着每秒计算量都是10的9次方级别的。好在每一个像素的计算并不复杂，因此我们需要的就是想这样“鞭炮”一样的结构，大量的小额计算，每一个都不是很响，但是连在一起就噼里啪啦的。我们后面提到的，在GPU中的操作基本都是这样的结构。

同时，CPU将每一次的打包数据，也就是渲染图元，需要从内存送到显存中。这是因为显卡对显存的存取更迅速。因此，实际上每一次CPU发出的Draw Call指令，GPU往往可以很快完成，甚至快于CPU发出下一次的Draw Call指令。这是由于IO速度较慢导致的，虽然我们加入了缓冲区的结构，但是IO速度依然是渲染的瓶颈。为此，一个解决思路是批处理，CPU将多个Draw call指令打包，一次交给GPU。

理解渲染最重要的是：**为了渲染一帧，CPU和GPU必须都完成他们的任务**。他们中的任何一个花费了过长的时间去完成任务，都会造成渲染延迟。因此渲染管线的基本思路是：一是增强渲染管线的处理能力，这个好理解；二是减少渲染数据的数量和复杂性，如果数据太繁琐，GPU再强也顶不住。

### 几何阶段
接下来就是主要的流水线过程，在几何阶段中，我们要关注的是以下几个过程：

![GPU](https://s2.ax1x.com/2019/11/27/QCpeE9.png)
*图来源于 Real-time rendering 4th Edition*

#### 顶点着色器
顶点着色器是可以编程的一个环节，主要有两个工作：
- 计算顶点坐标。将顶点坐标映射到齐次裁剪空间，这个我们之后会提到
- 计算顶点颜色。通常这一步是通过对每个顶点加光照，计算顶点的位置和法线信息，最后存储计算得到的颜色信息。

这里有一个困扰了我很久的究极疑惑，就是顶点怎么会有法向量？最后在知乎上找到了这样一个回答[顶点法向量的方向是怎样的？ - 夏清的回答 - 知乎](https://www.zhihu.com/question/294271776/answer/544982916)

![img](https://s2.ax1x.com/2019/11/27/QCklvt.jpg)
*图来源于 libigl.github.io*

可以看到，如果我们通过三角形片元的法线进行计算的话，算出来就是一片一片的，如最左的图。如果想得到更平滑的图，就需要让每一个顶点拥有一个法向量，顶点因为是多个片元三角形共享的，因此通过某种处理（可能是平均）后获得。这就是顶点法向量的来历，这个法向量还与共享的几个三角形片元的二面角有关。

