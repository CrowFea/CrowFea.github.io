---
title: 面向对象和类
date: 2020-2-2 16:21:12
categories:
    - C++
tags: 
    - C++
mathjax: true
---

### 封装
将客观事物封装成抽象的类，类可以将自己的数据和方法只让可信的类或者对象操作，对不可信的信息进行隐藏。默认为private。
* public ：可以被任意实体访问
* protected ：可以被子类及本类的成员函数访问
* private ：可以被本类的成员函数和友元类、友元函数访问
这几个关键字可以出现无数次。
<!--more-->
*Protected是传家宝，只可以在家族中访问；private是日记本，可以分享给自己和朋友，但不会告诉家人*

### 继承
基类/父类 —— 派生类/子类。
C++中的继承方式有：
Public、private、protected三种（它们直接影响到派生类的成员、及其对象对基类成员访问的规则）。
* public（公有继承）：继承时保持基类中各成员属性不变，并且基类中private成员被隐藏。派生类的成员只能访问基类中的public/protected成员，而不能访问private成员；派生类的对象只能访问基类中的public成员。
* private（私有继承）：继承时基类中各成员属性均变为private，并且基类中private成员被隐藏。派生类的成员也只能访问基类中的public/protected成员，而不能访问private成员；派生类的对象不能访问基类中的任何的成员。
* protected（保护性继承）：继承时基类中各成员属性均变为protected，并且基类中private成员被隐藏。派生类的成员只能访问基类中的public/protected成员，而不能访问private成员；派生类的对象不能访问基类中的任何的成员。
* 
### 多态
多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。多态是以封装和继承为基础的。
C++的多态有四种形式。编译期的多态为静态多态、运行期的多态为动态多态。
* 重载（编译器）：函数重载、运算符重载
* 参数多态（编译期）：类模板、函数模板
* 子类型多态（运行期）：虚函数
* 强制多态（编译期/运行期）：基本类型转换、自定义类型转换
* 
#### 多态相关有几个问题：
* 重载的规则
	* 函数名称必须相同
	* 参数列表必须不同（个数、类型、排列顺序）
	* 函数的返回类型可以相同也可以不同
	* 仅仅返回类型不同不构成重载
	
* C语言为什么不支持多态
编译器在编译.c文件的时候，只会给函数进行简单的命名（在函数名前面加_)，因此无法区分重载函数。
C++在处理重载的时候，其编译器在符号表中的名称不同。如 ?Add@@YAHHH@Z ：?表示名称开始，后面接函数名，@@YA表示参数表开始，后面三个表示返回值类型、参数类型，@Z表示名称结束。

* 虚函数的机制
![img](https://s2.ax1x.com/2020/03/03/3fWeg0.png)

* 虚函数的规则
	* 非类成员函数不能是虚函数
	* 静态函数不能是虚函数
	* 构造函数不能是虚函数
	* 内联函数不能是表现多态性时的虚函数
	
* 虚函数和纯虚函数
纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。
  virtual int A() = 0;
	* 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
	* 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。
	* 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
	* 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
	* 虚基类是虚继承中的基类。
	
### 几种特殊的类
* 抽象类：含有纯虚函数的类
* 接口类：仅含有纯虚函数的抽象类
* 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
	* 所有成员都是 public
	* 没有定义任何构造函数
	* 没有类内初始化
	* 没有基类，也没有 virtual 函数 



