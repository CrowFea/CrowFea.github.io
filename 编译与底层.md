---
title: 编译与底层
date: 2020-2-1 16:21:12
categories:
    - C++
tags: 
    - 编译原理
mathjax: true
---

### C++源文件从文本到可执行文件经历的过程
对于C++源文件，从文本到可执行文件一般需要四个过程：
- 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。
- 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
- 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
- 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件
<!--more-->
### include头文件的顺序以及双引号””和尖括号<>的区别
Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。

双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。

对于使用双引号包含的头文件，查找头文件路径的顺序为：
- 当前头文件目录
- 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）
- 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径

对于使用尖括号包含的头文件，查找头文件的路径顺序为：
- 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）
- 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径

### C++的内存管理
在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。
- 代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
- 数据段：存储程序中已初始化的全局变量和静态变量
- Bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。
- 堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。
- 映射区:存储动态链接库以及调用mmap函数进行的文件映射
- 栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值

### 什么是内存泄漏
内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。
内存泄漏的分类：
1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.
2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

### 什么时候会发生段错误
段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：
- 使用野指针
- 试图修改字符串常量的内容


