<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="crowfea,刘思源，刘思源的博客，crowfeablog，同济，四元君">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          数据结构笔记——排序算法总结 - CrowFea | Blog
        
    </title>

    <link rel="canonical" href="https://crowfeablog.com/article/数据结构笔记——排序/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/article_header/article_header.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#数据结构" title="数据结构">数据结构</a>
                            
                              <a class="tag" href="/tags/#排序算法" title="排序算法">排序算法</a>
                            
                        </div>
                        <h1>数据结构笔记——排序算法总结</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by CrowFea on
                            2018-12-21
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">四元君</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/archive/">档案室</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">关于我</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">标签</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h3 id="0问题描述">0.问题描述</h3>
<p>排序算法分为简单排序（时间复杂度为O(n^2))和高效排序（时间复杂度为O(nlog n)）。</p>
<p>本题给定N个整数，要求输出从小到大排序后的结果。 请用不同的排序算法（直接插入排序，折半插入排序，希尔排序，冒泡排序，快速排序，选择排序，归并排序，堆排序）分别进行测试，查看每个算法的运行时间和通过组数，进行对比分析，总结，写入报告中。</p>
<h3 id="1直接插入排序">1.直接插入排序</h3>
<p>插入排序将一个数列看成分割的两部分。一部分是顺序已知的子数列S，另一部分是顺序未知的数列US。每次排序时，将US中的数逐个的与S中的数进行比较，并且在找到合适的位置后进行插入。重复该行为。</p>
<p>插入排序一共通过了10组数据，运行样例的时间为1453ms，在数据量较少时表现良好。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void straightInsertSort(int arr[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, temp = -1;</span><br><span class="line">    int index = 0;</span><br><span class="line">    for (i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        index = i - 1;</span><br><span class="line">        while (index &gt;= 0 &amp;&amp; arr[index] &gt; temp) &#123;</span><br><span class="line">            arr[index + 1] = arr[index];</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index + 1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2折半插入排序">2.折半插入排序</h3>
<p>1、将待排序序列的第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
<p>2、从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置，在查找元素的适当位置时，采用了折半查找方法。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</p>
<p>折半插入通过的样例为12组，运行样例的时间为14266ms。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void binary_insertion_sort(int arr[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, temp, m, low, high;</span><br><span class="line">    for (i = 1; i &lt; len; i++)&#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        low = 0;</span><br><span class="line">        high = i - 1;</span><br><span class="line">        while (low &lt;= high)&#123;</span><br><span class="line">            m = (low + high) / 2;</span><br><span class="line">            if (arr[m] &gt; temp)&#123;</span><br><span class="line">                high = m - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                low = m + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (j = i - 1; j &gt;= high + 1; j--)</span><br><span class="line">            arr[j + 1] = arr[j];</span><br><span class="line">        arr[j + 1] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3希尔排序">3.希尔排序</h3>
<p>基于插入排序发展而来。希尔排序的思想基于两个原因： 1）当数据项数量不多的时候，插入排序可以很好的完成工作。 2）当数据项基本有序的时候，插入排序具有很高的效率。</p>
<p>基于以上的两个原因就有了希尔排序的步骤：</p>
<p>a.将待排序序列依据步长(增量)划分为若干组，对每组分别进行插入排序。初始时，step=len/2，此时的增量最大，因此每个分组内数据项个数相对较少，插入排序可以很好的完成排序工作（对应1）。</p>
<p>b.以上只是完成了一次排序，更新步长step=step/2,每个分组内数据项个数相对增加，不过由于已经进行了一次排序，数据项基本有序，此时插入排序具有更好的排序效率(对应2)。直至增量为1时，此时的排序就是对这个序列使用插入排序，此次排序完成就表明排序已经完成。</p>
<p>总的来说，希尔排序的意义在于，先对数列进行宏观上的调整，在逐步进行微观的调整。</p>
<p>希尔排序通过的样例为15组全部通过，运行样例的时间为12265ms.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void shellSort(int arr[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    int j = 0, tmp = 0;</span><br><span class="line">    for (int d = len / 2; d &gt; 0; d /= 2)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = d; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i - d;</span><br><span class="line">            tmp = arr[i];</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; arr[j] &gt; tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j + d] = arr[j];</span><br><span class="line">                j -= d;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + d] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4冒泡排序">4.冒泡排序</h3>
<p>冒泡排序所采用的办法是进行n次比较，每次比较时从数组的第一个元素开始，两个相邻的元素逐个比较，以升序为例，将较大的元素后移。如此进行完第一次比较后，所有元素中最大的元素就沉到最后。再进行第二次比较，从第一个元素比较至倒数第二个元素。</p>
<p>冒泡排序通过的样例共8组，运行时间为8609ms，在小数据时运行很快。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void bubble_sort1(int *arr,int len)&#123;</span><br><span class="line">    int max = len-1;</span><br><span class="line">    int i,j;</span><br><span class="line">    for(i=0;i&lt;max;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;max-i;j++)&#123;</span><br><span class="line">            if(arr[j+1]&lt;arr[j])&#123;</span><br><span class="line">                swap(arr,j,j+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5快速排序">5.快速排序</h3>
<p>速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为 O(NlogN)。</p>
<p>快速排序通过的样例为11组，运行样例的时间为13750ms。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void quick_sort_recursive(int arr[], int start, int end) &#123;</span><br><span class="line">    if (start &gt;= end) return;</span><br><span class="line">    int base = arr[end];</span><br><span class="line">    int left = start, right = end - 1;  </span><br><span class="line">    while (true) &#123;</span><br><span class="line">        while (arr[left] &lt; base) ++left;</span><br><span class="line">        while (arr[right] &gt;= base) --right;</span><br><span class="line">        if (left &gt;= right) break;</span><br><span class="line">        swap(arr[left], arr[right]);   </span><br><span class="line">    &#125;</span><br><span class="line">    if (arr[left] &gt;= arr[end]) swap(arr[left], arr[end]);  </span><br><span class="line">    else ++left;</span><br><span class="line">    quick_sort_recursive(arr, start, left - 1);</span><br><span class="line">    quick_sort_recursive(arr, left + 1, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6选择排序">6.选择排序</h3>
<p>选择排序是经过n次遍历，每次遍历都选择最值放置到数列一端。然后在遍历剩下的数，最终完成排序。</p>
<p>选择排序的通过样例为8组，运行时间为4109ms，在小数据时运行很快。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void selectSort(int arr[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; len - 1; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">     int index = i;</span><br><span class="line">            for (int j = i + 1; j &lt; len; ++j)</span><br><span class="line">                     &#123;</span><br><span class="line">                        if (arr[j] &lt; arr[index])</span><br><span class="line">                                 index = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                if (index != i)</span><br><span class="line">                    &#123;</span><br><span class="line">                         int temp = arr[i];</span><br><span class="line">                        arr[i] = arr[index];</span><br><span class="line">                         arr[index] = temp;</span><br><span class="line">                   &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7归并排序">7.归并排序</h3>
<p>归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。归并排序有多路归并排序、两路归并排序 ,可用于内排序，也可以用于外排序。这里仅对内排序的两路归并方法进行讨论。</p>
<p>算法思路：</p>
<p>把 n 个记录看成 n 个长度为 l 的有序子表</p>
<p>进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表</p>
<p>重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。</p>
<p>归并排序通过15组数据，用时3930ms，十分迅速。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void Merge(int a[],int left,int mid,int right)</span><br><span class="line">&#123;</span><br><span class="line">    int length1 = mid-left+1;</span><br><span class="line">    int length2 = right-mid;</span><br><span class="line">    int i, j;</span><br><span class="line">    int *l1 = new int[length1];</span><br><span class="line">    int *l2 = new int[length2];</span><br><span class="line"> </span><br><span class="line">    for (i = 0; i &lt; length1; ++i)&#123;</span><br><span class="line">        l1[i] = a[left+i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (j = 0; j &lt; length2; ++j)&#123;</span><br><span class="line">        l2[j] = a[j+mid+1];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    i = 0;</span><br><span class="line">    j = 0;</span><br><span class="line">    int k = length1;</span><br><span class="line"></span><br><span class="line">    while (i&lt;length1 &amp;&amp; j&lt;length2)&#123;</span><br><span class="line">        if (l1[i] &lt; l2[j])&#123;</span><br><span class="line">            a[left++] = l1[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            a[left++] = l2[j++];</span><br><span class="line">            if (l2[j] &gt; l1[i])&#123;</span><br><span class="line">                //_count +=  length1-i+1;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //两序列的剩余部分分别放于结尾</span><br><span class="line">    while (i&lt;length1)&#123;</span><br><span class="line">        a[left++] = l1[i++];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    while (j&lt;length2)&#123;</span><br><span class="line">        a[left++] = l2[j++];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    delete []l1;</span><br><span class="line">    delete []l2;</span><br><span class="line">&#125;</span><br><span class="line">void Merge_sort(int a[],int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">    if (left &lt; right)&#123;</span><br><span class="line">        int mid = (left+right)/2;</span><br><span class="line">        Merge_sort(a,left,mid);</span><br><span class="line">        Merge_sort(a,mid+1,right);</span><br><span class="line">        Merge(a,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8堆排序">8.堆排序</h3>
<p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p>
<p>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</p>
<p>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆</p>
<p>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</p>
<p>堆排序通过15组数据，用时4625ms，十分迅速。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void Heap_build(int a[],int root,int length)</span><br><span class="line">&#123;</span><br><span class="line">    int lchild = root*2+1;//根节点的左子结点下标</span><br><span class="line">    if (lchild &lt; length)//左子结点下标不能超出数组的长度</span><br><span class="line">    &#123;</span><br><span class="line">        int flag = lchild;//flag保存左右节点中最大值的下标</span><br><span class="line">        int rchild = lchild+1;//根节点的右子结点下标</span><br><span class="line">        if (rchild &lt; length)//右子结点下标不能超出数组的长度(如果有的话)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[rchild] &gt; a[flag])//找出左右子结点中的最大值</span><br><span class="line">            &#123;</span><br><span class="line">                flag = rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a[root] &lt; a[flag])</span><br><span class="line">        &#123;</span><br><span class="line">            //交换父结点和比父结点大的最大子节点</span><br><span class="line">            swap(a,root,flag);</span><br><span class="line">            //从此次最大子节点的那个位置开始递归建堆</span><br><span class="line">            Heap_build(a,flag,length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Heap_sort(int a[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = len/2; i &gt;= 0; --i)//从最后一个非叶子节点的父结点开始建堆</span><br><span class="line">    &#123;</span><br><span class="line">        Heap_build(a,i,len);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (int j = len-1; j &gt; 0; --j)//j表示数组此时的长度，因为len长度已经建过了，从len-1开始</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a,0,j);//交换首尾元素,将最大值交换到数组的最后位置保存</span><br><span class="line">        Heap_build(a,0,j);//去除最后位置的元素重新建堆，此处j表示数组的长度，最后一个位置下标变为len-2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结：</h3>
<p>在八种排序算法中。</p>
<p>堆排序、归并排序效率最好。不仅可对大数据进行排序，在时间上也非常稳定。</p>
<p>快速排序，希尔排序，折半插入效率也较好，但在小数据量时表现不佳。尤其是快速排序十分不稳定。</p>
<p>冒泡排序，选择排序，直接插入排序在小数据时十分迅速，但在较大的数据时表现不佳。</p>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/leetcode笔记-12.整数转罗马数/" data-toggle="tooltip" data-placement="top" title="leetcode笔记——12.整数转罗马数">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/leetcode笔记-11.盛最多水的容器/" data-toggle="tooltip" data-placement="top" title="leetcode笔记——8.实现atoi函数">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                    <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                    <!--  css & js -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#0问题描述"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">0.&#x95EE;&#x9898;&#x63CF;&#x8FF0;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1直接插入排序"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">1.&#x76F4;&#x63A5;&#x63D2;&#x5165;&#x6392;&#x5E8F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2折半插入排序"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">2.&#x6298;&#x534A;&#x63D2;&#x5165;&#x6392;&#x5E8F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3希尔排序"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">3.&#x5E0C;&#x5C14;&#x6392;&#x5E8F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4冒泡排序"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">4.&#x5192;&#x6CE1;&#x6392;&#x5E8F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5快速排序"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">5.&#x5FEB;&#x901F;&#x6392;&#x5E8F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6选择排序"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">6.&#x9009;&#x62E9;&#x6392;&#x5E8F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7归并排序"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">7.&#x5F52;&#x5E76;&#x6392;&#x5E8F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8堆排序"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">8.&#x5806;&#x6392;&#x5E8F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#总结"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">&#x603B;&#x7ED3;&#xFF1A;</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#数据结构" title="数据结构">数据结构</a>
                        
                          <a class="tag" href="/tags/#排序算法" title="排序算法">排序算法</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>










    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/CrowFea">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; CrowFea 2019 
                    <br>
                    
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://crowfeablog.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://crowfeablog.com/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
