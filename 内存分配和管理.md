---
title: C++内存管理
date: 2020-2-2 16:21:12
categories:
    - C++
tags: 
    - 内存
mathjax: true
---

### 关于几个函数
* malloc：分配指定字节数的内存，初始值不确定
* calloc：为指定长度的对象分配能容纳其个数的内存。每一位初始化为0
* realloc：更改以前分配的内存长度，初始值不确定
* alloca：在栈中发申请内存，出栈时自动释放内存，不具有移植性。
<!--more-->
### 堆和栈的区别
- 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
- 空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。
- 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。
- 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
- 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
- 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

### new和delete
相比而言，new和delete实际上都干了两件事：首先调用malloc/free分别申请/释放了内存；接下来调用构造/析构函数。

**定位new（placement new）**允许我们向new传递额外的地址参数，从而在预先指定的内存区域创建对象。
```c++
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] { braced initializer list }
```
place_address 是个指针；initializers 提供一个（可能为空的）以逗号分隔的初始值列表。

### delete this
合法，但：
* 必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的
* 必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数
* 必须保证成员函数的 delete this 后面没有调用 this 了
* 必须保证 delete this 后没有人使用了

### 如何定义一个只能在堆上（栈上）生成对象的类?
* 只能在堆上：将析构函数设置为私有
原因是C++是一个静态绑定的语言。在编译过程中，所有的非虚函数调用都必须分析完成。即使是虚函数，也需检查可访问性。因些，当在栈上生成对象时，对象会自动析构，也就说析构函数必须可以访问。而堆上生成对象，由于析构时机由程序员控制，所以不一定需要析构函数。保证了不能在栈上生成对象后，需要证明能在堆上生成它。delete操作会调用析构函数。所以不能编译。
那么如何释放它呢？答案也很简单，提供一个成员函数，完成delete操作。在成员函数中，析构函数是可以访问的。当然detele操作也是可以编译通过。 
```c++
void OnlyHeapClass::Destroy() { 
        delete this; 
} 
```
构造函数私有化的类的设计可以保证只能用new命令在堆中来生成对象，只能动态的去创建对象，这样可以自由的控制对象的生命周期。但是，这样的类需要提供创建和撤销的公共接口。

* 只能在栈上：将 new 和 delete 重载为私有
原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。

### 分配位置
Malloc和new分配都在堆上；函数内的局部变量、形参都是在栈中，自动释放的。

### 大端小端
大端存储：低地址位存储高位；
小端存储：高地址位存储高位
