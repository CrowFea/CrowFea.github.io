---
title: 小程序开发-云开发模板消息
date: 2019-5-24 17:29:12
categories:
    - 小程序
tags: 
    - 小程序
mathjax: true
---

                

### 需求

有时候我们需要小程序向用户发送通知。比如说需要支付，提示支付成功；需要报名，提示报名成功等。一般这种情况我们有两种方法：

*   使用模板消息，发送的结果显示在微信的服务通知
*   连接公众号，发送消息的时候直接在公众号进行发送。

毫无疑问，如果我没有公众号推广之类的任务的话，强行让用户关注一个只给他发消息的公众号有点愚蠢，我们这里还是采用模板消息的做法。

### 什么是模板消息

<s>**烦死人的玩意儿**</s>

> 基于微信的通知渠道，我们为开发者提供了可以高效触达用户的模板消息能力，以便实现服务的闭环并提供更佳的体验。
> 
> 模板推送位置：服务通知
> 
> 模板下发条件：用户本人在微信体系内与页面有交互行为后触发，详见下发条件说明
> 
> 模板跳转能力：点击查看详情仅能跳转下发模板的该帐号的各个页面

简单来说，就是给了一个使用微信官方通知服务的接口。但是模板消息有诸多的限制:

只有两种行为可以引发模板消息：

*   支付

    当用户在小程序内完成过支付行为，可允许开发者向用户在**7天内推送有限条数的模板消息**（**1次支付可下发3条**，多次支付下发条数独立，互相不影响）

*   提交表单

    当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在**7天内推送有限条数的模板消息**（**1次提交表单可下发1条**，多次提交下发条数独立，相互不影响）

因此这给我们带来了一定的麻烦：

*   如何在用户没提交的情况下发送
*   如何在一个用户提交后向另一个用户通知

    我们在后续会使用一些方法解决。

### 使用模板消息的准备

模板消息有着比较复杂的发送方式。他需要以下几样东西：

*   模板消息号 templateID。

    这个直接在微信开发者后台申请，开发者后台提供了大量的模板可以使用，这里主要看的就是title和keywords的数量就好了。申请好后得到templateID。

    ![img](https://s2.ax1x.com/2019/05/23/VCauOU.png)

*   appid和appsecret

    这两个参数作为标识，来和后台进行模板消息的确认和发送。直接在后台获取。

    值得注意的是，appsecret不能显式的表示，直接复制到剪贴板，注意保存。

接下来前期的配置就ok了，我们来看一看模板消息的接口：

![img](https://s2.ax1x.com/2019/05/23/VCaIts.png)

这里需要注意的就是需要用户的openid和一个formid。openid我们在之前的文章中说过[小程序-获取用户信息](https://crowfeablog.com/article/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E4%B8%89%E8%BF%9E/)，接下来我们详细的说一说formid。

### formid

#### 意义

我们可以理解为，发送一次模板消息就像打枪。需要一个目标和一发子弹。openid就是目标，formid就是子弹。

上面已经说了，用户在提交表单或者支付的时候会引发模板消息，这是因为在特定的模板消息相应按钮下，我们生成了一个**只用于当前openid的formid**。每次在发送后，这个formid就失效了。因此可以立即为formid是一个消耗品。

**注意在生成formid的时候，不能将生成的formid强行塞到另一个openid的记录里。**

这么一来我们就能针对性的解决一些问题。

#### 一次发送多个消息

有些小程序，比如说打卡类的程序。是需要不断地提醒用户来玩的。或者日历类的，一天一推是必要的。但是formid必须是用户自主生成。所以我们必须要让用户一次生成足够多的formid，存储下来作为之后一周内的储备。

formid的表单的提交可以埋在任何的button处，只需要在该组件的外层加上一对<form>标签。注意在button中设置formType=“submit”。</form>

```js
<form report-submit="true" bindsubmit="button_two">
  <button formType="submit">发送</button>
</form>
```

一个button生成一个formid，我们可以增加生成formid的按钮，在程序中埋雷，等着用户踩就完事了。

#### 在一个用户提交后向另一个用户通知

这个功能同样也常见。比如说我们有一个协作类的程序，需要在一方做完后向另一方通知。由于每一个formid和openid都是对应的，我们这时在用户数据库中拿到目标用户的openid，那这个检索他的formid，取出来。将这两个参数传入来进行发送。

### 实现

#### 生成formid

这里我在每一个formid中打上了时间戳。
```js
save_formid(e) {
    console.log(e.detail.formId)
    console.log(new Date())
    db.collection('formId').add({
      data: {
        openid: wx.getStorageSync("openid"),
        formId: e.detail.formId,
        date: (new Date()).valueOf()
      }
    })
      .then(res => {
        console.log(res)
      })
  },
```

#### 发送模板消息云函数

在这个地方加入自己的appid和appsecret用来换取access_token
```js
/ 云函数入口文件
const cloud = require('wx-server-sdk')
const got = require('got');
//输入自己的APPID和SECRET
const reptileUrl = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=&secret=";
//分别填入appid和secret
const MessageUrl = "https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token="
cloud.init()
// 云函数入口函数
exports.main = async (event, context) => {
  let data = JSON.stringify({
    touser: event.openid,
    template_id: event.template_id,
    page: event.page,
    form_id: event.form_id,
    data: JSON.parse(event.data),
    emphasis_keyword: event.emphasis_keyword
  })
  console.log(data)
  let http = await got(reptileUrl)
  console.log(JSON.parse(http.body).access_token)
  let access_token = JSON.parse(http.body).access_token
  let Message = await got(MessageUrl + access_token, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: data
  })
  return Message.body
}
```

#### 发送模板消息
```js
button_two(e) {
    let week = new Date() - (1000 * 60 * 60 * 24 * 7) //建立7天时间戳
    //储存formId，并打时间戳
    db.collection('formId').add({
      data: {
        openid: wx.getStorageSync("openid"),
        formId: e.detail.formId,
        date: (new Date()).valueOf()
      }
    })
      .then(res => {
        console.log(res)
      })
    //获取formId数据 
    db.collection('formId').where({
      _openid: "",
      date: _.gt(week) //获取7天内
    }).get().then(res => {
      console.log(res.data)
      var formIdList = res.data
      let date = new Date();
      let data = JSON.stringify({
        "keyword1": {
          "value": "fasfasf"
        },
        "keyword2": {
          "value": date
        }
      })
      //调用云函数发送模版消息
      wx.cloud.callFunction({
        name: 'moban',
        data: {
          openid: formIdList[0].openid,
          template_id: "",
          //page: "/pages/fromID/index?sender_openid=" + wx.getStorageSync("openid") + "&value=" + value, //携带参数
          form_id: formIdList[0].formId,
          data,
          emphasis_keyword: "keyword1.DATA"
        },
        success: res => {
          console.log('模版消息发送成功: ', res)
          this.remove(formIdList[0]._id); //调用删除formId函数
        },
        fail: err => {
          console.error('模版消息发送失败：', err)
        }
      })
    })
  },
  ```

注意在生成formid的时候必须要真机调试，要不然生成出来的formid是mock one。